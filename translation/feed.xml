<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Translations on 0xab.de</title><link>/translation/</link><description>Recent content in Translations on 0xab.de</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 03 Feb 2020 00:00:00 +0000</lastBuildDate><atom:link href="/translation/feed.xml" rel="self" type="application/rss+xml"/><item><title>如何实现分布式锁定</title><link>/translation/2020/02/2020-02-03-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9A/</link><pubDate>Mon, 03 Feb 2020 00:00:00 +0000</pubDate><guid>/translation/2020/02/2020-02-03-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9A/</guid><description>原文地址：https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html
作为我的书研究的一部分，我在 Redis 的官网上偶然发现了一个叫做 Redlock的算法。这个算法声称能在 Redis 上实现容错的分布式锁（准确地说是租约[1]），同时在页面上向研究分布式系统的人征求意见。这个算法本能性的在我的脑海里敲响了警钟，所以我花了些时间来思考并且写下了这些笔记。
因为已经有十多个 Redlock 的独立实现了，并且我们不知道谁已经依赖于这个算法。所有值得把我的笔记公开分享出来。我不会深入探讨 Redis 的其他方面，因为那些已经在其他地方批评过了。
在我深入 Redlock 的细节之前，我要声明我十分喜欢 Redis，并且之前已经在生产环节中成功的应用过它了。我认为它非常适合在服务器之间共享一些快速变化的数据，而且如果偶尔丢了这些数据也无关紧要。例如，维护每个 IP 地址的请求计数器（出于限制的目的）和每个用户 ID 的不同 IP 地址集(用于滥用的检测)。
然而，Redis 已经逐渐进入有强一致性和持久性特点的数据管理领域，这让我很担心，因为这不是 Redis 设计的初衷。有争议的是，分布式锁定也是这一领域之一。让我们更详细地研究一下。
你用锁来干什么 锁的目的是用来保证在多个节点尝试做同样的工作时，只有一个能够实际完成（至少在同一时间只有一个）。这个工作可能是将一些数据写入一个共享的存储系统、完成一些计算、调用一些外部的 API 或者其他类似的工作。宏观上来看，有两个原因来解释你为什么在一个分布式应用中想要一个锁：效率和正确性[2]。为了区别出这些情况，可以往下看当锁失败的时候会发生什么：
效率：应用锁可以避免做不必要的重复工作（例如一些代价昂贵的计算）。如果锁失效了，并且两个节点做相同的工作，结果就是成本略有增加（最后要比其他方式多给 AWS 支付5美分）或带来小小的不便（用户可能会收到两个相同的邮件通知）。 正确性：应用锁可以避免并发进程相互影响最终搞乱系统的状态。如果锁失效了，并且两个节点同时处理同一部分数据，结果可能是损坏的文件、数据丢失、永久的不一致性、给病人服用了错误剂量的药物或其他严重的问题。 以上两点都是需要锁的有效情况，但是你需要十分明确你是在处理哪一个情况。
我的观点是：如果只是为了效率的目的，那么没有必要承担 Redlock 的成本和复杂性，没有必要运行5台 Redis 实例来检查是否有大多数服务器都获得了锁。你最好只启动一个 Redis 实例，或是当主节点崩溃时异步复制到从节点。
如果你使用单个 Redis 实例，在 Redis 节点断电时会失去一些锁，同时可能会出现一些问题。但是如果你使用这些锁来优化效率的话，同时节点的崩溃也不会频繁发生，那么这也没什么大不了。这个“没什么大不了”的正是 Redis 的特点。至少当你依赖于一个 Redis 实例的时候，每个查看系统的人都知道这些锁是不太严谨的，并且仅用于非关键的目的。
另一方面，具有5个副本和多数投票的 Redis 算法乍一看似乎适用于对正确性要求很高的情况。在接下来的几个章节中我将论证它不适合这个目的。文章的其余部分我们假定你的锁对保障正确性至关重要，并且两个节点持有相同的锁是一个严重的错误。
使用锁来保护资源 让我们把 Redlock 的具体应用放一边，先讨论一下通常一个分布式锁是如何使用的（不依赖于某个锁定算法）。记住分布式系统中的锁和多线程应用中的互斥量不一样这一点很重要。由于不同的节点和网络都能以各种方式独不同的方式发生故障，所以这是一个更复杂的野兽。
例如，假如你有一个应用，其中客户端需要更新共享存储中的文件（如 HDFS 或 S3）。一个客户端首先获得一个锁，然后读取这个文件，作出一个修改，将改动写回，最终释放这个锁。这个锁避免两个客户端同时执行读-修改-写这个循环，这将会导致丢失更新。代码可能如下：
// THIS CODE IS BROKEN function writeData(filename, data) { var lock = lockService.</description></item></channel></rss>