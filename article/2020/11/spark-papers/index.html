<!doctype html><html><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>Spark Papers - arjenzhou</title><meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="Spark: Cluster Computing with Working Sets MapReduce （下称 MR）任务包含主要五两个步骤：Map、Sort、Combine、Shuffle、 Reduce，每个 MR 任务在 Map 将数据阶段将数据转换成 K-V 的形式；Reduce 在不同的机器上作聚合运算。Shuffle 更是涉及到巨大的 I/O 操作（主要是网络 I/O）。每个 MR 任务最终会将计算结果写回存储系统。
由于 MR 任务的最终结果会写回存储，那么有两种经典场景对于它来说是低效的：
迭代任务（迭代机器学习算法） 交互式数据分析工具 Spark 提出了 RDD (Resilient Distributed Dataset) 模型来处理此类问题。RDD 是一个被分布在一组机器上的只读的对象集，当一个分区丢失时 RDD 能够很快通过重新计算的方式来重建。RDD 能够被保存在内存中，并以类似 MR 的 并行操作方式 得到重用。RDD 通过一种叫做 血统（lineage） 的概念实现容错：如果 RDD 的一部分丢失了，那么 RDD 有足够的信息（该 RDD 是怎么从其他 RDD 计算出来的）来重建该部分。
在 Spark 中，RDD 以 Scala 对象的形式存在。并且 RDD 能够通过以下几种形式构造出来：
来自共享文件系统（如 HDFS）中的一个文件 并行化（parallelizing） 一个 Scala 集合 转化（transforming）于一个已经存在的 RDD 改变一个已存在 RDD 的持久性（persistence） cache：将 RDD 暂存于内存以便稍后重用 save：将 RDD 存于类似 HDFS 的分布式文件系统 对于 cache 这种情况来说，如果集群中没有足够的内存来缓存一个数据集（dataset）的所有部分，那么 Spark 会在使用它们时重新计算。"><meta property="og:image" content><meta property="og:title" content="Spark Papers"><meta property="og:description" content="Spark: Cluster Computing with Working Sets MapReduce （下称 MR）任务包含主要五两个步骤：Map、Sort、Combine、Shuffle、 Reduce，每个 MR 任务在 Map 将数据阶段将数据转换成 K-V 的形式；Reduce 在不同的机器上作聚合运算。Shuffle 更是涉及到巨大的 I/O 操作（主要是网络 I/O）。每个 MR 任务最终会将计算结果写回存储系统。
由于 MR 任务的最终结果会写回存储，那么有两种经典场景对于它来说是低效的：
迭代任务（迭代机器学习算法） 交互式数据分析工具 Spark 提出了 RDD (Resilient Distributed Dataset) 模型来处理此类问题。RDD 是一个被分布在一组机器上的只读的对象集，当一个分区丢失时 RDD 能够很快通过重新计算的方式来重建。RDD 能够被保存在内存中，并以类似 MR 的 并行操作方式 得到重用。RDD 通过一种叫做 血统（lineage） 的概念实现容错：如果 RDD 的一部分丢失了，那么 RDD 有足够的信息（该 RDD 是怎么从其他 RDD 计算出来的）来重建该部分。
在 Spark 中，RDD 以 Scala 对象的形式存在。并且 RDD 能够通过以下几种形式构造出来：
来自共享文件系统（如 HDFS）中的一个文件 并行化（parallelizing） 一个 Scala 集合 转化（transforming）于一个已经存在的 RDD 改变一个已存在 RDD 的持久性（persistence） cache：将 RDD 暂存于内存以便稍后重用 save：将 RDD 存于类似 HDFS 的分布式文件系统 对于 cache 这种情况来说，如果集群中没有足够的内存来缓存一个数据集（dataset）的所有部分，那么 Spark 会在使用它们时重新计算。"><meta property="og:type" content="article"><meta property="og:url" content="/article/2020/11/spark-papers/"><meta property="article:section" content="article"><meta property="article:published_time" content="2020-11-13T00:00:00+00:00"><meta property="article:modified_time" content="2020-11-13T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Spark Papers"><meta name=twitter:description content="Spark: Cluster Computing with Working Sets MapReduce （下称 MR）任务包含主要五两个步骤：Map、Sort、Combine、Shuffle、 Reduce，每个 MR 任务在 Map 将数据阶段将数据转换成 K-V 的形式；Reduce 在不同的机器上作聚合运算。Shuffle 更是涉及到巨大的 I/O 操作（主要是网络 I/O）。每个 MR 任务最终会将计算结果写回存储系统。
由于 MR 任务的最终结果会写回存储，那么有两种经典场景对于它来说是低效的：
迭代任务（迭代机器学习算法） 交互式数据分析工具 Spark 提出了 RDD (Resilient Distributed Dataset) 模型来处理此类问题。RDD 是一个被分布在一组机器上的只读的对象集，当一个分区丢失时 RDD 能够很快通过重新计算的方式来重建。RDD 能够被保存在内存中，并以类似 MR 的 并行操作方式 得到重用。RDD 通过一种叫做 血统（lineage） 的概念实现容错：如果 RDD 的一部分丢失了，那么 RDD 有足够的信息（该 RDD 是怎么从其他 RDD 计算出来的）来重建该部分。
在 Spark 中，RDD 以 Scala 对象的形式存在。并且 RDD 能够通过以下几种形式构造出来：
来自共享文件系统（如 HDFS）中的一个文件 并行化（parallelizing） 一个 Scala 集合 转化（transforming）于一个已经存在的 RDD 改变一个已存在 RDD 的持久性（persistence） cache：将 RDD 暂存于内存以便稍后重用 save：将 RDD 存于类似 HDFS 的分布式文件系统 对于 cache 这种情况来说，如果集群中没有足够的内存来缓存一个数据集（dataset）的所有部分，那么 Spark 会在使用它们时重新计算。"><link href=/css/fonts.b685ac6f654695232de7b82a9143a46f9e049c8e3af3a21d9737b01f4be211d1.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=/css/main.39ebaad9fc9f12a7ee415682ebf69793198eb40de807ad546a08fe9ad5e51438.css><link id=darkModeStyle rel=stylesheet type=text/css href=/css/dark.726cd11ca6eb7c4f7d48eb420354f814e5c1b94281aaf8fd0511c1319f7f78a4.css media="(prefers-color-scheme: dark)"><link rel=stylesheet href=/katex/katex.min.css><script defer src=/katex/katex.min.js></script><script defer src=/katex/contrib/auto-render.js onload=renderMathInElement(document.body)></script><script src=https://unpkg.com/mermaid@8.8.1/dist/mermaid.min.js></script></head><body><div class=content><header><div class=main><a href=/>arjenzhou</a></div><nav><a href=/article>Article</a>
<a href=https://arjenzhouhz.notion.site>Notion</a>
<a href=/translation>Translation</a>
<a href=/reproduction>Reproduction</a>
<a href=/categories>Category</a>
<a href=/feed.xml>Subscribe</a></nav></header><main><article><div class=title><h1 class=title>Spark Papers</h1><span class=link></span><div class=meta>Posted on Nov 13, 2020</span><hr></div></div><section class=body><h2 id=spark-cluster-computing-with-working-sets>Spark: Cluster Computing with Working Sets</h2><p>MapReduce （下称 MR）任务包含主要<del>五</del>两个步骤：Map、<del>Sort、Combine、Shuffle、</del> Reduce，每个 MR 任务在 Map 将数据阶段将数据转换成 K-V 的形式；Reduce 在不同的机器上作聚合运算。Shuffle 更是涉及到巨大的 I/O 操作（主要是网络 I/O）。每个 MR 任务最终会将计算结果写回存储系统。</p><p>由于 MR 任务的最终结果会写回存储，那么有两种经典场景对于它来说是低效的：</p><ol><li>迭代任务（迭代机器学习算法）</li><li>交互式数据分析工具</li></ol><p>Spark 提出了 RDD (Resilient Distributed Dataset) 模型来处理此类问题。RDD 是一个被分布在一组机器上的只读的对象集，当一个分区丢失时 RDD 能够很快通过重新计算的方式来重建。RDD 能够被保存在内存中，并以类似 MR 的 <em>并行</em>操作方式 得到重用。RDD 通过一种叫做 <em>血统（lineage）</em> 的概念实现容错：如果 RDD 的一部分丢失了，那么 RDD 有足够的信息（该 RDD 是怎么从其他 RDD 计算出来的）来重建该部分。</p><p>在 Spark 中，RDD 以 Scala 对象的形式存在。并且 RDD 能够通过以下几种形式构造出来：</p><ol><li>来自共享文件系统（如 HDFS）中的一个<em>文件</em></li><li><em>并行化（parallelizing）</em> 一个 Scala 集合</li><li><em>转化（transforming</em>）于一个已经存在的 RDD</li><li>改变一个已存在 RDD 的<em>持久性（persistence）</em><ul><li><em>cache</em>：将 RDD 暂存于内存以便稍后重用</li><li><em>save</em>：将 RDD 存于类似 HDFS 的分布式文件系统</li></ul></li></ol><p>对于 <em>cache</em> 这种情况来说，如果集群中没有足够的内存来缓存一个数据集（dataset）的所有部分，那么 Spark 会在使用它们时重新计算。</p><p>通常来说，当一个函数被传递给 Spark 操作（Spark operation）到一个集群中时，该操作会在这个函数中所有变量的多份副本上执行。这些变量被复制到各个机器上，但对这些变量的更新不会再传播回到驱动程序（driver program）上。而对共享变量的读/写是低效的。所以：</p><p>Spark 允许用户创建两种受限制的<em>共享变量（shared variables）<em>来支持两种简单但常见的用法</em>：</em></p><ol><li><p><em>Broadcast variables</em></p><p>广播变量允许开发者将一个只读的变量缓存在每台机器上，而不是随着任务传输一个副本。对于共享变量来说，只有在多个阶段需要同样数据的情况才是一个高效的使用方式。</p></li><li><p><em>Accumulators</em></p><p>累加器通常可以用来作计数器。每个累加器在创建时得到一个独特的 ID，在 workers 上，累加器在每个线程上创建一个线程本地（thread-local）变量。当一个任务开始时被重置为0，workers 将其发送给驱动程序让其累加。</p></li></ol><p>Spark 实现的核心是 RDD，举个🌰</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#66d9ef>val</span> file <span style=color:#66d9ef>=</span> spark<span style=color:#f92672>.</span>textFile<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;hdfs://...&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>val</span> errs <span style=color:#66d9ef>=</span> file<span style=color:#f92672>.</span>filter<span style=color:#f92672>(</span><span style=color:#66d9ef>_</span><span style=color:#f92672>.</span>contains<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;ERROR&#34;</span><span style=color:#f92672>))</span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>val</span> cachedErrs <span style=color:#66d9ef>=</span> errs<span style=color:#f92672>.</span>cache<span style=color:#f92672>()</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>val</span> ones <span style=color:#66d9ef>=</span> cachedErrs<span style=color:#f92672>.</span>map<span style=color:#f92672>(</span><span style=color:#66d9ef>_</span> <span style=color:#66d9ef>=&gt;</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>val</span> count <span style=color:#66d9ef>=</span> ones<span style=color:#f92672>.</span>reduce<span style=color:#f92672>(</span><span style=color:#66d9ef>_</span><span style=color:#f92672>+</span><span style=color:#66d9ef>_</span><span style=color:#f92672>)</span>
</span></span></code></pre></div><p>这些数据集将会以一组对象的链路存储，也就是 RDD 的<em>血统，</em> 如图1所示。每个数据集对象包含一个指向它父亲的指针和对它是如何从它父亲那里计算出来的说明。</p><p><img src=/pic/post/2020/11/spark-1.png alt></p><p>图1，RDD 对象的血统链路</p><hr><h2 id=resilient-distributed-datasets-a-fault-tolerant-abstraction-for-in-memory-cluster-computing>Resilient Distributed Datasets: A Fault-Tolerant Abstraction for In-Memory Cluster Computing</h2><p>RDD 因当前（Spark 诞生前）计算框架对迭代算法和交互式数据挖掘工具支持的低效而诞生。这两者的共同点是都将数据保存在内存中，以此来提高性能。RDD 提供基于粗粒度的转换（transformations）的内存模型，而不是细粒度的对共享内存的更新。</p><p>对于之前已有的框架来说，尽管能够利用集群的计算资源，但是缺少对集群内存的使用。这使得能够<em>重用</em>中间结果的应用变得低效。</p><p>设计 RDD 的最大挑战是能够提供<em>容错</em>和<em>高效</em>的编程接口。对于已有的集群内存存储的抽象，例如分布式共享内存（DSM）、K-V 存储、数据库和 Piccol，它们提供了一个细粒度的基于对可变状态的更新的接口。这种接口提供容错的仅有方式是：</p><ol><li>将数据备份到不同机器上</li><li>在机器之间更新日志。</li></ol><p>这两种方式对于数据密集型任务来说是很昂贵的，因为它们都需要在集群间复制大量的数据。而这种集群的网络带宽要比内存小得多。</p><p>和这些系统相比，RDD 提供了基于粗粒度的转换（transformations）的接口。通过记录构造 RDD 的血统关系而不是数据本身来提供容错性。若 RDD 的一部分丢失，那么有足够多的关于它如何从其它 RDD 转换过来的信息来重新计算这个部分。</p><p>RDD 是一个只读的分散（partitioned）记录。它能从对</p><ol><li>稳定存储</li><li>其它RDD</li></ol><p>的操作得到。</p><p>这种操作被叫做 <em>transformations</em> 以来区分对 RDD 的其它操作。</p><p>同时，用户能够指定 RDD 的重用、存储策略，根据实际需要将 RDD 划分开（partitioning）。用户能够“持久化” RDD，并将其存储在内存中，当内存不足时可以根据策略落盘或进行其它操作。尽管 RDD 是不可变的，但是可以通过多版本 RDD 来间接实现 RDD 的可变性。</p><p>RDD 与分布式共享内存（DSM）的主要区别在于 RDD 只通过粗粒度的变化（transformations）来创建（对于 RDD 的读仍然是细粒度的），而 DSM 允许在每个内存区域中读写。由于 RDD 通过其血统实现容错，故它不需要检查点（checking point）。此外，只有丢失的部分才会被重新计算，并且丢失的部分可以被许多机器并行地计算。</p><p>RDD 的另一个好处在于它的不可变性，这个特点让系统通过在其它节点上执行慢任务的副本来减轻慢节点（stragglers）的情况，这个做法和 MR 类似。但是这在 DSM 中很难实现，因为它同个任务的两个副本会访问同一块共享内存。归功于局部性原理，可以将任务调度在同一个节点上（或类似的做法）来提高性能。</p><p>对于 RDD ，它适用于对数据集中应用相同操作的批处理；而不适用于对共享状态的异步细粒度更新。</p><p>理想上来说，实现 RDD 的系统应该提供丰富的转换操作集合，并且能够让用户自由地组合它们。实际上 RDD 的实现是通过一个简单的基于图的方式做到的。简要来说，RDD 是通过以下五点做到的：</p><ol><li>一组部分（a set of <em>partitions</em>）</li><li>父 RDD 的一组依赖（<em>a set of dependencies</em> on parent RDDs）</li><li>基于父 RDD 的计算函数（a function for computing the dataset based on its parents）</li><li>分散方案的元数据（metadata about its partitioning scheme）</li><li>数据存放的位置（data placement）</li></ol><p>描述 RDD 之间的依赖的一个有效方法是将其分为两种类型：</p><ol><li><p><em>narrow</em> dependencies</p><p>每个父 RDD 的一个 partition 只被至多一个子 RDD 的一个 partition 使用</p></li><li><p><em>wide</em> dependencies</p><p>多个子 RDD 的 partitions 依赖父 RDD 的 partition</p></li></ol><p>由于 <em>narrow</em> dependencies 的依赖关系十分简单（一对一依赖），故它能够在一个节点上以流水线的方式执行。而 <em>wide</em> dependencies 则需要类似 <em>shuffle</em> 的操作。同理，对 <em>narrow</em> dependencies 节点的恢复也更简单。</p><p>针对 <em>wide</em> denpendencies，目前采用在节点上存储中间记录的方式存储父 partitions，以此来简化容错。</p><p><img src=/pic/post/2020/11/spark-2.png alt></p><p>图2，<em>narrow</em> dependencies 和 <em>wide</em> dependencies 的示例。每个方格是一个 RDD，阴影矩形是 partitions</p><p>当 RDD 的血统特别长或依赖特别宽时，恢复 RDD 变得昂贵。这时提供检查点的方式来降低开销，Spark 可以从最近的检查点开始恢复来最小化系统的恢复时间。RDD 的不可变性使得检查点容易实现，因为它不会带来并发安全问题。</p><hr><h2 id=spark-sql-relational-data-processing-in-spark>Spark SQL: Relational Data Processing in Spark</h2><p>受益于 Spark SQL，Spark 能够借助关系处理的优点，同时让 SQL 用户体验到强大的 Spark 类库。与其它系统相比，Spark SQL 提供了关系性和程序处理的紧密结合——通过陈述式的 DataFrame API。其次，它引入了一个叫做 Catalyst 的高扩展性优化器。</p><p>Spark SQL 通过 DataFrame API 在外部数据源和内建分布式集合之间建造起了桥梁。DataFrame 是能够通过使用 Spark API 来操作的数据结构集合，它能够直接通过 Java/Python 对象来创建。</p><p>构建 Spark SQL 的原因在于：</p><ol><li>提供用户友好的 API 在 Spark 程序内部和外部数据源上支持关系化处理</li><li>使用建立 DMBS 的技巧来提供高性能</li><li>易于支持新的数据源，包括半结构化数据和外部数据源</li><li>能够扩展高级分析算法（如图处理和机器学习算法）</li></ol><p>Spark 暴露出了一个 SQL 接口，能够通过 JDBC/ODBC 的形式访问，此外也能通过 Spark 支持语言的 DataFrame API 访问，如图3。</p><p><img src=/pic/post/2020/11/spark-3.png alt></p><p>图3，Spark SQL 接口和与 Spark 的交互</p><p>对 Spark SQL API 的主要抽象是 DataFrame，它是相同 schema 下 row 的分布式集合。一个 DataFrame 与关系型数据库中的一张表是等价的。并且它能够以 RDD 相似的方式来操作。与 RDD 不同的是，它会追踪他们的 schema 并且支持多种能够优化的关系性操作。</p><p>DataFrame 可以从外部数据源的表中构造出来，也可以通过已经存在的 RDD 得到。DataFrame 是惰性的，只有在用户调用特殊的输出操作才会真正的执行，因为这样能够充分地利用优化器的特性。</p><p>DataFrame 能够注册作为临时表并执行查询。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span>users<span style=color:#f92672>.</span>where<span style=color:#f92672>(</span>users<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;age&#34;</span><span style=color:#f92672>)</span> <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>21</span><span style=color:#f92672>)</span> 
</span></span><span style=display:flex><span>	<span style=color:#f92672>.</span>registerTempTable<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;young&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>ctx<span style=color:#f92672>.</span>sql<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;SELECT count(*), avg(age) FROM young&#34;</span><span style=color:#f92672>)</span>
</span></span></code></pre></div><p>这种特性能够让他在内存中执行聚合操作。</p><p>与 ORM 框架相比，ORM 框架会将整个对象转换成不同的格式。而 Spark SQL 只会在每次查询中在原地访问所需的列。这种访问原生数据集的能力能够让用户在 Spark 程序中执行优化过的关系操作。此外，也能让 RDD 与外部结构数据的结合更简单。（实现不同数据源之间的关联）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#66d9ef>case</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>User</span><span style=color:#f92672>(</span>name<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>String</span><span style=color:#f92672>,</span> age<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Int</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Create an RDD of User objects 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>usersRDD <span style=color:#66d9ef>=</span> spark<span style=color:#f92672>.</span>parallelize<span style=color:#f92672>(</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>List</span><span style=color:#f92672>(</span><span style=color:#a6e22e>User</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Alice&#34;</span><span style=color:#f92672>,</span> <span style=color:#ae81ff>22</span><span style=color:#f92672>),</span> <span style=color:#a6e22e>User</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Bob&#34;</span><span style=color:#f92672>,</span> <span style=color:#ae81ff>19</span><span style=color:#f92672>)))</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// View the RDD as a DataFrame 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>usersDF <span style=color:#66d9ef>=</span> usersRDD<span style=color:#f92672>.</span>toDF
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>views <span style=color:#66d9ef>=</span> ctx<span style=color:#f92672>.</span>table<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;pageviews&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>usersDF<span style=color:#f92672>.</span>join<span style=color:#f92672>(</span>views<span style=color:#f92672>,</span> usersDF<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;name&#34;</span><span style=color:#f92672>)</span> <span style=color:#f92672>===</span> views<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;user&#34;</span><span style=color:#f92672>))</span>
</span></span></code></pre></div><hr><h2 id=discretized-streams-fault-tolerant-streaming-computation-at-scale>Discretized Streams: Fault-Tolerant Streaming Computation at Scale</h2><p>许多大数据应用以实时的方式来进行计算，而已有的流式计算模型（D-Streams 之前的）只能提供昂贵的容错方式。为了克服这些困难，D-Streams 提供了一个并行恢复的机制来提高传统副本和备份方式的效率，同时解决了掉队者（计算较慢的节点）的问题。</p><p>设计这个模型的两个巨大挑战是：</p><ol><li>错误</li><li>掉队者（慢节点）</li></ol><p>这两个问题在大集群中都是不可避免的。流式应用必须快速地恢复，因为每一秒延迟恢复意味着大量数据处理的丢失。</p><p>不幸的是，已有的流处理系统很难处理错误和掉队者。大多数分布式流处理系统如 Storm、TimeStream、MapReduce Online 和流式数据都是基于连续算子（continuous operator）模型构建的。这种模型通常长时间运行，有状态的算子接受每条记录、更新其内部状态、并且发送新记录。这些模型过于简单，很难处理错误和掉队者。</p><p>通常对于连续算子模型来说，系统恢复有两种方式：</p><ol><li><p>副本（replication）</p><p>每个节点上放两个副本</p></li><li><p>上游备份（upstream backup）</p><p>发送节点缓存发送的消息，当下游失败时重发</p></li></ol><p>这两种方式对大型集群来说都不够友好：</p><p>副本需要至少两倍的硬件；而上游备份需要很长时间来恢复，整个系统需要等待一个新节点按顺序通过重新运算来重建失败节点的状态。</p><p>此外，这两种方式都没有处理掉队者的情况：</p><p>在上游备份方式中，掉队者必须作为<em>失败</em>的情况来处理，增加了一个恢复的步骤；备份系统使用像 Flux 的同步协议来协调副本，所以一个掉队者会使副本都变慢。</p><p>副本（replication）是数据库常见采用的形式。此种情况在处理图中有两个副本， 并且输入记录被发送到这两处。简单做副本是不够的，系统同样需要<em>同步协议来</em>保证每个算子的两个副本以相同的顺序看到上游数据，因为相同的顺序产生相同的输出流。尽管能够快速地从失败中恢复，副本也是代价很高的。</p><p>在上游复制中，每个节点保存从某个检查点开始发送的消息副本，当节点失败时会有机器替代它，上游会将消息发送来让其重建。这种方式会导致很长的恢复时间，因为一个节点必须通过重新计算一系列有状态的算子代码来恢复它丢失的状态。</p><p><img src=/pic/post/2020/11/spark-4.png alt></p><p>图4，Spark Streaming 的高层次概览</p><p>D-Streams 克服了这些问题。舍弃管理长活的算子，它构造了一组短时间间隔上无状态、确定性的批计算作为一个流计算。为了实现这样的模型，D-Streams：</p><ol><li>给定输入数据的情况下可以完全确定每个时间步的<em>状态</em>，从而无需同步协议</li><li>能以精细粒度看到此状态与较早数据之间的依赖</li></ol><p>实现 D-Streams 有两个挑战：</p><p>第一个是降低延迟（时间间隔粒度）。传统的批处理系统通过将状态存在副本中来实现，而 D-Streams 是通过 RDD 做到的。</p><p>第二个是快速地从失败和掉队者中恢复。D-Streams 提供了一个新的恢复机制来实现：<em>并行恢复</em>丢失节点的状态。当一个节点失败时，集群中的每个节点都重新计算 RDD 的每一部分，在没有副本的消耗的同时，这也要比上游备份要快得多。对于掉队者，D-Streams 用猜测执行的方式来恢复，这在之前提到的流式系统中没有处理过。</p><p>D-Streams 将流计算看作一系列对小时间间隔的确定批处理计算。每个时间间隔接收到的<em>输入数据集</em>被可靠地存放在集群中。一旦时间间隔结束后，这个数据集通过像 <em>map</em>、<em>reduce</em> 和 <em>groupBy</em> 这样的确定的并行操作被处理掉来产生代表输出或者中间状态的新数据集。对于前者，结果可能被存储到外部存储中；而后者以 RDD 的形式存放。</p><p>D-Streams 是一个不可变的、分割开的数据集序列，它能被施加以确定的<em>转化（transformations）。<em>这些转化产生新的 D-Streams，也可能创建 RDD 的形式的中间</em>状态。</em></p><p>D-Streams 根据每个记录到达系统的时间来将其放入输入数据集中。因为需要保证系统总是及时地开始一个新的批次，并且让应用能够在同一位置生成记录。</p><p>由于 D-Streams 主要是一个执行策略（描述如何将一个计算分成小步），它们可以用来实现许多流式的标准操作。</p><p>D-Streams <em>transformations</em> 和 <em>output operation</em> 与 RDD 类似。此外还提供了几个有状态的转化（transformations）。</p><ul><li><p><strong>Windowing</strong></p><p>将一段时间窗口内的记录组合起到一个 RDD 中</p></li><li><p><strong>Incremental</strong> <strong>aggregation</strong></p></li></ul><p>按时间窗口聚合</p><ul><li><strong>State tracking</strong></li></ul><p>追踪状态的变化</p><p>D-Streams 的一致性机制非常简单，因为时间能自然地离散到时间间隔上，每个时间间隔输出的 RDD 反映这个和上一个时间间隔的所有输入。这在无论输出和状态 RDD 是否被分散到集群中都是一样的。</p><p>D-Streams 与其它持续算子系统的区别在于它将任务分割成小的、确定的批任务。尽管提高了延迟下限，但是能够高效地恢复。</p><hr><h2 id=structured-streaming-a-declarative-api-for-real-time-application-in-apache-spark>Structured Streaming: A Declarative API for Real-Time Application in Apache Spark</h2><p>借助于 Spark Streaming 的成功经验，Structured Streaming 在 API 上做了一定层次的升华。首先，它是一个基于自动递增静态关系查询的纯<em>声明式</em> API，与要求用户构建 DAG 物理算子的 API 形成鲜明对比；其次，Structured Streaming 致力于支持将流与批处理和交互式分析集成<em>端到端</em>的实时应用。这种集成通常是一个重大挑战。</p><p>Spark Streaming 遇到的问题：</p><ul><li>需要用户去考虑复杂的物理执行概念</li><li>只关注于流计算，但实际应用上经常与批处理分析、与静态数据的关联和交互式查询</li></ul><p>为此，Structured Streaming 提供了两种形式的 API：</p><ol><li><p>增量查询模型</p><p>Structured Streaming 通过 Spark SQL 和 Spark batch API 来表达静态数据集上的自增查询，这意味着用户只需理解 Spark batch 的 API 就能写出一个流式查询。</p></li><li><p>支持端到端的应用</p></li></ol><p>此外，Structured Streaming 采取了几个手段来简化操作。第一，Structured Streaming 重用 Spark SQL 执行引擎，包括它的优化器和运行时代码生成器。第二，设计了一个支持失败、代码更新和重计算输出数据的引擎。比如，新数据的到来导致应用崩溃，更可怕的情况是输出了错误的数据。在 Structured Streaming 中，每个应用维护一个易懂的 JSON 格式 write-ahead event log，管理员能够使用它们在任意时间重启应用。如果应用由于自定义的函数（UDF）崩溃了，管理员能够更新 UDF 并让应用在跌倒的地方爬起来。若输出了错误的结果，也能手动回滚到问题发生之前。</p><p>由于其复杂的 API，流式应用要比批处理难用是共识。还有些新需求如：在收到全部数据之前，系统应该输出什么样的中间结果？由于流式 API 天生的<em>低级</em>特性，它们经常要求用户在复杂的物理算子而不是更陈述式的层面上明确系统。其它诸如 Google Dataflow 模型，需要用户为每个聚合算子指定一个 windowing mode、triggering mode 和 trigger refinement mode 来确定算子是输出增量还是累加结果。而像 Spark Streaming 和 Flink 的 DataStream API，需要编写一个物理算子的 DAG，并提供一系列管理状态的复杂操作。Structured Sreaming 使用其增量查询模型，在设计该模型的同时，发现在模型中增加定制的<em>有状态处理</em>算子也会让高级用户构建他们自己的处理逻辑。</p><p>几乎所有的流式工作都在大型应用的环境下运行，这种情况经常需要很大的工程负担。许多流式 API 只需要关注从一端读并写到另一端，而端到端的商业应用需要进行其它任务：</p><ol><li>对新数据的交互查询</li><li>ETL 任务需要将流与其它存储系统或批计算的数据连接（join）</li><li>需要将流式业务逻辑以批处理的形式运行</li></ol><p>部署流式应用的巨大挑战之一是管理和操作，已知问题包括：</p><ul><li>失败</li><li>代码更新</li><li>扩展性</li><li>掉队者</li><li>监控</li></ul><p>除了操作和工程问题之外，流式应用的性能也是其一大问题，因为它总是以24/7的状态运行的。若没有动态扩展，在波峰之外的时间应用会浪费大量的资源。即使有了扩展性，持续计算也比周期批处理的任务要昂贵。为此，Structured Streaming 借助了 Spark SQL 中所有的执行优化。性能的首要优化项是<em>吞吐量</em>，因为它是大型流式应用中的重要指标。</p><p>Structured Streaming 连接了一组输入输出源。为了提供“恰好一次”输出和容错，它在输入和输出上给出了两个限制：</p><ul><li>输入必须是<em>可重复的（replayable）</em>，当节点崩溃时允许系统重读最近的输入</li><li>输出必须支持<em>幂等</em>写，确保写时节点崩溃能够可靠恢复。若下游输出目标支持，Structured Streaming 能提供原子性的输出。即使是多个节点并行工作，整个任务的输出也应展现成是原子的</li></ul><p>除外部系统外，Structured Streaming 也支持 Spark SQL 的输入和输出。用户能从任意的 Spark 批输入源计算一个静态表，也能将其和一个流连接。或是让 Structured Streaming 输出成一个内存中能交互式查询的 Spark 表。</p><p>Structured Streaming 以两种形式的持久化存储实现容错。</p><ul><li>通过 WAL 来追踪哪个数据被处理，每个输入源的 WAL 被可靠地写入输出</li><li>系统使用一个大型<em>状态存储</em>来保存长期运行聚合算子状态的快照</li></ul><p>这两种都可以存储在可插拔的存储系统中。</p><p>Structured Streaming 的语义如下：</p><ol><li>每个输入源根据时间提供一组部分有序结果（如来自 Kafka 的不同 partition）</li><li>用户提供一个查询，它在能够在输入数据之间执行，该输入数据能在任何处理时间点输出一个<em>结果表</em></li><li><em>触发器（Triggers）</em> 告诉系统何时去运行一个新的增量计算，何时更新结果表。</li><li>下游的<em>输出模式</em>明确了结果表如何被写入输出系统。目前支持三种模式：<ul><li><em>Complete</em>：一次将结果写入</li><li><em>Append</em>：只向下游添加记录</li><li><em>Update</em>：根据每个记录的 key 来更新下游</li></ul></li></ol><p>图5阐述了这个模型，结果表的内容逻辑上只是一个永远不会物化的视图。</p><p><img src=/pic/post/2020/11/spark-5.png alt></p><p>图5，Strucutred Streaming 两种输出方式的语义</p><p>该模型的第二个吸引人的特性是它有强大的一致性语义，叫做<em>前缀一致性（prefix consistency）。</em></p><p>首先，它保证在一个输入源中输入记录相对有序时，输出被合并到相同的记录中。其次，由于结果表是基于输入前缀中的所有数据一次定义的，结果表中所有的行都对应到输入记录上。</p><hr></section><div class=post-tags></div></article><h1>Comments:</h1><div id=cusdis_thread data-host=https://cusdis.com data-app-id=71c1c07d-0104-4d23-9cbc-827c46070d54 data-page-id=7d0054427b078a004677dfc714a6b7f1 data-page-url=/article/2020/11/spark-papers/ data-page-title="Spark Papers"></div><script async defer src=https://cusdis.com/js/cusdis.es.js></script></main><footer><hr>⚡️
2024 <a href=https://github.com/athul/archie>Archie Theme</a> | Built with <a href=https://gohugo.io>Hugo</a></footer></div></body></html>